<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Datalake</title>
  <style>
    :root { --border:#e2e8f0; --bg-alt:#f8fafc; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    header { background: #0f172a; color: white; padding: 12px 16px; }
    main { padding: 0; height: calc(100vh - 56px); display:flex; }
    .pane { flex:1; display:flex; flex-direction:column; min-width:0; border-right:1px solid var(--border); }
    .pane:last-child { border-right:none; }
    .pane header.pane-header { background:#ffffff; padding:12px 16px; border-bottom:1px solid var(--border); display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .pane header.pane-header h3 { margin:0; font-size:16px; }
    .pane .content { padding:16px; overflow:auto; }
    .controls { display: flex; gap: 8px; align-items: center; margin-bottom: 12px; flex-wrap:wrap; }
    .tree ul { list-style: none; padding-left: 16px; }
    .tree li { margin: 2px 0; }
    code { background: var(--bg-alt); padding: 2px 4px; border-radius: 4px; }
    .muted { color: #64748b; }
    textarea { width:100%; min-height:160px; font-family: monospace; font-size:12px; }
    button { cursor:pointer; }
    .split { display:flex; gap:8px; }
    .status { font-size:12px; }
    .error { color:#b91c1c; }
    .success { color:#047857; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    label { font-size:12px; display:flex; flex-direction:column; gap:2px; }
    input { padding:4px 6px; }
    .sessions-select { margin-top:16px; border-top:1px solid var(--border); padding-top:12px; }
    .sessions-select h4 { margin:0 0 8px 0; font-size:14px; }
    .sessions-list { display:flex; flex-direction:column; gap:4px; }
    .gen-bar { margin-top:12px; display:flex; align-items:center; gap:12px; }
    .gen-bar button { padding:6px 10px; }
    .pill { display:inline-block; background:var(--bg-alt); border:1px solid var(--border); border-radius:12px; padding:2px 8px; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h2>Datalake</h2>
  </header>
  <main>
    <!-- Data Pane -->
    <div class="pane" id="data-pane">
      <header class="pane-header">
        <h3>Data</h3>
        <label>Project
          <input id="project" placeholder="my-project" />
        </label>
        <label>Session
          <input id="session" placeholder="s1" />
        </label>
        <label>TagId
          <input id="tagid" placeholder="sensor" />
        </label>
        <label>View
          <select id="view">
            <option value="nested">Nested</option>
            <option value="flat">Flat</option>
          </select>
        </label>
        <button id="load">Load</button>
        <div class="row" style="margin-left:auto;">
          <button id="clear-project" style="color:#b91c1c;">Clear project</button>
          <button id="clear-all" style="color:#7f1d1d;">Clear ALL</button>
        </div>
      </header>
      <div class="content">
        <div id="clear-status" class="status muted" style="margin-bottom:8px;"></div>
        <section id="output"></section>
        <!-- Inline session selection now lives inside the data tree; generation controls appended below -->
      </div>
    </div>
    <!-- Config Pane -->
    <div class="pane" id="config-pane">
      <header class="pane-header">
        <h3>Config</h3>
        <label style="min-width:160px;">Project (shared)
          <input id="config-project" disabled />
        </label>
        <label>Version
          <input id="config-version" type="number" min="1" placeholder="(latest)" style="width:90px;" />
        </label>
        <button id="config-load">Fetch</button>
        <button id="config-new-version" title="Create new version from editor">Save New Version</button>
        <span id="config-meta" class="muted" style="font-size:12px;"></span>
      </header>
      <div class="content">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:4px;">
          <strong>Current Version JSON</strong>
          <span id="config-status" class="status muted"></span>
        </div>
        <pre id="config-view" style="background:var(--bg-alt); padding:8px; border:1px solid var(--border); border-radius:4px; max-height:240px; overflow:auto;">(no config loaded)</pre>
        <div style="margin-top:16px;">
          <strong>New Version Editor</strong>
          <textarea id="config-editor" placeholder="{\n  \"example\": true\n}"></textarea>
        </div>
      </div>
    </div>
  </main>
  <script>
    // Data elements
    const out = document.getElementById('output');
    const statusEl = document.getElementById('clear-status');
    const projectInput = document.getElementById('project');
    const configProjectInput = document.getElementById('config-project');
  let genBtn; let genStatus; // created dynamically
    // Config elements
    const configVersionInput = document.getElementById('config-version');
    const configView = document.getElementById('config-view');
    const configStatus = document.getElementById('config-status');
    const configMeta = document.getElementById('config-meta');
    const configEditor = document.getElementById('config-editor');

    function syncProjectToConfig() {
      configProjectInput.value = projectInput.value.trim();
    }
    projectInput.addEventListener('input', () => { syncProjectToConfig(); });
    document.getElementById('load').addEventListener('click', async () => {
      const project = document.getElementById('project').value.trim();
      const session = document.getElementById('session').value.trim();
      const tagid = document.getElementById('tagid').value.trim();
      const view = document.getElementById('view').value;
      if (!project) { alert('Enter project'); return; }
      out.textContent = 'Loading...';
      const params = new URLSearchParams({ project, nest: view === 'flat' ? 'flat' : 'session,tagid,description' });
      if (session) params.set('session', session);
      if (tagid) params.set('tagid', tagid);
      const res = await fetch(`/api/data?${params.toString()}`);
      if (!res.ok) { out.textContent = 'Error: ' + res.statusText; return; }
      const data = await res.json();
      if (view === 'flat') {
        renderFlat(data);
      } else {
        const norm = normalizeResponse(data);
        renderNested(norm);
      }
      // Also fetch config latest after data load if project defined
      await loadConfig();
    });

    document.getElementById('clear-project').addEventListener('click', async () => {
      const project = document.getElementById('project').value.trim();
      if (!project) { alert('Enter project'); return; }
      if (!confirm(`Are you sure you want to clear project '${project}'? This cannot be undone.`)) return;
      statusEl.textContent = 'Clearing project...';
      const res = await fetch(`/api/data?project=${encodeURIComponent(project)}`, { method: 'DELETE' });
      if (!res.ok) { statusEl.textContent = 'Failed to clear project'; return; }
      const data = await res.json();
      statusEl.textContent = `Cleared project '${project}'. Removed ${data.removed ?? 0} entries.`;
      out.innerHTML = '';
    });

    document.getElementById('clear-all').addEventListener('click', async () => {
      if (!confirm('Are you absolutely sure you want to CLEAR ALL DATA? This action is irreversible.')) return;
      statusEl.textContent = 'Clearing all data...';
      const res = await fetch('/api/data', { method: 'DELETE' });
      if (!res.ok) { statusEl.textContent = 'Failed to clear all data'; return; }
      const data = await res.json();
      statusEl.textContent = `Cleared all data. Removed ${data.removed ?? 0} entries.`;
      out.innerHTML = '';
    });

    async function loadConfig(explicit = false) {
      const project = projectInput.value.trim();
      if (!project) { if (explicit) alert('Enter project'); return; }
      syncProjectToConfig();
      configStatus.textContent = 'Loading...';
      const version = configVersionInput.value ? Number(configVersionInput.value) : undefined;
      const params = new URLSearchParams({ project });
      if (version) params.set('version', String(version));
      try {
        const res = await fetch(`/api/config?${params.toString()}`);
        if (!res.ok) {
          configStatus.textContent = 'Not found';
          configView.textContent = '(no config)';
          configMeta.textContent = '';
          return;
        }
        const data = await res.json();
        configView.textContent = JSON.stringify(data.config, null, 2);
        configMeta.textContent = `version ${data.version} (latest ${data.latest})`;
        configStatus.textContent = 'Loaded';
        // Prefill editor with current config as starting point
        if (!configEditor.value.trim()) configEditor.value = JSON.stringify(data.config, null, 2);
      } catch (e) {
        configStatus.textContent = 'Error fetching config';
      }
    }

    document.getElementById('config-load').addEventListener('click', () => loadConfig(true));
    configVersionInput.addEventListener('keydown', e => { if (e.key === 'Enter') loadConfig(true); });
    document.getElementById('config-new-version').addEventListener('click', async () => {
      const project = projectInput.value.trim();
      if (!project) { alert('Enter project'); return; }
      let parsed;
      try {
        parsed = JSON.parse(configEditor.value || 'null');
      } catch (e) {
        alert('Editor content is not valid JSON');
        return;
      }
      configStatus.textContent = 'Saving new version...';
      try {
        const res = await fetch('/api/config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ project, config: parsed }) });
        if (!res.ok) { configStatus.textContent = 'Save failed'; return; }
        const data = await res.json();
        configStatus.textContent = 'Saved v' + data.version;
        configVersionInput.value = '';
        await loadConfig();
      } catch (e) {
        configStatus.textContent = 'Error saving';
      }
    });

    function renderFlat({ project, items }) {
      out.innerHTML = `<h3>Project: ${project}</h3><p>${items.length} item(s)</p>`;
      const ul = document.createElement('ul');
      for (const it of items) {
        const li = document.createElement('li');
        li.innerHTML = `<code>${new Date(it.timestamp).toISOString()}</code> <span class="muted">[${it.tagid}/${it.description}/${it.session}]</span> <pre>${escapeHtml(JSON.stringify(it.payload, null, 2))}</pre>`;
        ul.appendChild(li);
      }
      out.appendChild(ul);
    }

    function normalizeResponse(resp) {
      const project = resp.project;
      const data = resp.data || {};
      const norm = {};
      let hadNew = false;
      // Try new layout: session -> tagid -> description
      for (const sess in data) {
        const maybeTags = data[sess];
        if (maybeTags && typeof maybeTags === 'object' && !Array.isArray(maybeTags)) {
          for (const tag in maybeTags) {
            const maybeDescs = maybeTags[tag];
            if (maybeDescs && typeof maybeDescs === 'object' && !Array.isArray(maybeDescs)) {
              for (const desc in maybeDescs) {
                const items = maybeDescs[desc];
                if (Array.isArray(items)) {
                  if (!norm[sess]) norm[sess] = {};
                  if (!norm[sess][tag]) norm[sess][tag] = {};
                  if (!norm[sess][tag][desc]) norm[sess][tag][desc] = [];
                  norm[sess][tag][desc].push(...items);
                  hadNew = true;
                }
              }
            }
          }
        }
      }
      // If nothing parsed as new layout, try old layout: tagid -> description -> session
      if (!hadNew) {
        for (const tag in data) {
          const maybeDescs = data[tag];
          if (maybeDescs && typeof maybeDescs === 'object' && !Array.isArray(maybeDescs)) {
            for (const desc in maybeDescs) {
              const maybeSess = maybeDescs[desc];
              if (maybeSess && typeof maybeSess === 'object' && !Array.isArray(maybeSess)) {
                for (const sess in maybeSess) {
                  const items = maybeSess[sess];
                  if (Array.isArray(items)) {
                    if (!norm[sess]) norm[sess] = {};
                    if (!norm[sess][tag]) norm[sess][tag] = {};
                    if (!norm[sess][tag][desc]) norm[sess][tag][desc] = [];
                    norm[sess][tag][desc].push(...items);
                  }
                }
              }
            }
          }
        }
      }
      return { project, data: norm };
    }

    function renderNested({ project, data }) {
      out.innerHTML = `<h3>Project: ${project}</h3>`;
      const tree = document.createElement('div');
      tree.className = 'tree';
      const ul = document.createElement('ul');
      const selected = new Set();
      for (const sess in data) {
        const liSess = document.createElement('li');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.session = sess;
        cb.addEventListener('change', () => {
          if (cb.checked) selected.add(sess); else selected.delete(sess);
          updateGenControls(selected);
        });
        const sessLabel = document.createElement('span');
        sessLabel.innerHTML = `<strong>session:</strong> <code>${sess}</code>`;
        const headerWrap = document.createElement('div');
        headerWrap.style.display = 'flex';
        headerWrap.style.alignItems = 'center';
        headerWrap.style.gap = '6px';
        headerWrap.appendChild(cb);
        headerWrap.appendChild(sessLabel);

        // Annotation controls per session
        const annotateBtn = document.createElement('button');
        annotateBtn.textContent = 'Annotate';
        annotateBtn.style.fontSize = '12px';
        annotateBtn.dataset.mode = 'view'; // view | edit
        const annotateStatus = document.createElement('span');
        annotateStatus.className = 'status muted';
        annotateStatus.style.fontSize = '11px';
        const annotationEditorId = `annot-editor-${sess}`;

        function createEditor(existingPairs = {}) {
          const wrap = document.createElement('div');
          wrap.id = annotationEditorId;
          wrap.style.border = '1px solid var(--border)';
          wrap.style.padding = '6px 8px';
          wrap.style.borderRadius = '4px';
          wrap.style.background = 'var(--bg-alt)';
          wrap.style.margin = '4px 0 8px 24px';
          const title = document.createElement('div');
          title.style.display = 'flex';
          title.style.justifyContent = 'space-between';
          title.style.alignItems = 'center';
          title.innerHTML = `<strong>Annotations (key:value)</strong>`;
          wrap.appendChild(title);
          const list = document.createElement('div');
          list.style.display = 'flex';
          list.style.flexDirection = 'column';
          list.style.gap = '4px';
          wrap.appendChild(list);
          function addRow(key = '', value = '') {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.gap = '4px';
            row.style.alignItems = 'center';
            const k = document.createElement('input');
            k.placeholder = 'key';
            k.value = key;
            k.style.flex = '0 0 140px';
            const v = document.createElement('input');
            v.placeholder = 'value';
            v.value = value;
            v.style.flex = '1';
            const del = document.createElement('button');
            del.textContent = 'âœ•';
            del.title = 'Remove pair';
            del.style.fontSize = '11px';
            del.addEventListener('click', () => row.remove());
            row.appendChild(k); row.appendChild(v); row.appendChild(del);
            list.appendChild(row);
          }
          // Populate existing pairs first
          const keys = Object.keys(existingPairs);
          if (keys.length) {
            for (const k of keys) {
              const v = typeof existingPairs[k] === 'string' ? existingPairs[k] : '';
              addRow(k, v);
            }
          }
          // Trailing blank row for new input
          addRow();
          const addBtn = document.createElement('button');
          addBtn.textContent = 'Add Pair';
          addBtn.style.fontSize = '12px';
          addBtn.addEventListener('click', () => addRow());
          wrap.appendChild(addBtn);
          return wrap;
        }

        annotateBtn.addEventListener('click', async () => {
          const mode = annotateBtn.dataset.mode;
          const project = projectInput.value.trim();
          if (!project) { alert('Enter project first'); return; }
          if (mode === 'view') {
            // Enter edit mode
            annotateBtn.textContent = 'Save';
            annotateBtn.dataset.mode = 'edit';
            annotateStatus.textContent = '';
            // Create editor if not exists
            if (!liSess.querySelector(`#${annotationEditorId}`)) {
              // Find existing annotations for this session
              let existingPairs = {};
              const annTag = data[sess]['annotations'];
              if (annTag) {
                const annDesc = annTag['annotations'];
                if (annDesc && Array.isArray(annDesc)) {
                  // Backend merge guarantees at most one item
                  const first = annDesc[0];
                  const annPayload = first && first.payload && first.payload.annotations;
                  if (annPayload && typeof annPayload === 'object') {
                    for (const [k, v] of Object.entries(annPayload)) {
                      if (typeof v === 'string') existingPairs[k] = v;
                    }
                  }
                }
              }
              liSess.insertBefore(createEditor(existingPairs), liSess.firstChild.nextSibling); // after headerWrap
            }
          } else if (mode === 'edit') {
            // Collect and save
            const editor = liSess.querySelector(`#${annotationEditorId}`);
            if (!editor) { annotateStatus.textContent = 'Editor missing'; return; }
            const rows = Array.from(editor.querySelectorAll('div > input[placeholder="key"]')).map(kInput => kInput.parentElement);
            const annotations = {};
            let invalid = false;
            for (const row of rows) {
              const inputs = row.querySelectorAll('input');
              const key = inputs[0].value.trim();
              const value = inputs[1].value.trim();
              if (!key && !value) continue; // skip empty row
              if (!key) { invalid = true; annotateStatus.textContent = 'Annotation key required'; break; }
              annotations[key] = value;
            }
            if (invalid) return;
            annotateStatus.textContent = 'Saving...';
            annotateBtn.disabled = true;
            try {
              const body = { project, session: sess, tagid: 'annotations', description: 'annotations', timestamp: Date.now(), payload: { annotations } };
              const res = await fetch('/api/data', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
              if (!res.ok) {
                annotateStatus.textContent = 'Save failed';
              } else {
                annotateStatus.textContent = 'Saved';
                // Exit edit mode
                annotateBtn.textContent = 'Annotate';
                annotateBtn.dataset.mode = 'view';
                editor.remove();
                // Optionally reload data to display new annotations
                setTimeout(() => document.getElementById('load').click(), 300);
              }
            } catch (e) {
              annotateStatus.textContent = 'Error saving';
            } finally {
              annotateBtn.disabled = false;
            }
          }
        });
        headerWrap.appendChild(annotateBtn);
        headerWrap.appendChild(annotateStatus);
        liSess.appendChild(headerWrap);
        const ulPairs = document.createElement('ul');
        // Collapse by tagid: merge all descriptions under the same tagid and pick the first description as label
        const byTag = {};
        for (const tag in data[sess]) {
          for (const desc in data[sess][tag]) {
            const items = data[sess][tag][desc] || [];
            if (!byTag[tag]) byTag[tag] = { description: desc, items: [] };
            // If a different description appears for the same tagid, keep the first seen as canonical label
            byTag[tag].items.push(...items);
          }
        }
        for (const tag in byTag) {
          const { description, items } = byTag[tag];
          const liPair = document.createElement('li');
          liPair.innerHTML = `<strong>tagid/description:</strong> <code>${tag}/${description}</code> <span class="muted">(${items.length})</span>`;
          const ulItems = document.createElement('ul');
          for (const it of items) {
            const liIt = document.createElement('li');
            liIt.innerHTML = `<code>${new Date(it.timestamp).toISOString()}</code> <pre>${escapeHtml(JSON.stringify(it.payload, null, 2))}</pre>`;
            ulItems.appendChild(liIt);
          }
          liPair.appendChild(ulItems);
          ulPairs.appendChild(liPair);
        }
        liSess.appendChild(ulPairs);
        ul.appendChild(liSess);
      }
      tree.appendChild(ul);
      out.appendChild(tree);
      // Generation controls appended below tree
  const controlsWrap = document.createElement('div');
  controlsWrap.style.marginTop = '12px';
  // hidden container toggled by selection
  controlsWrap.style.display = 'none';
  const controls = document.createElement('div');
  controls.style.display = 'flex';
  controls.style.alignItems = 'center';
  controls.style.gap = '8px';
  // Prompt input for generation
  const promptInput = document.createElement('input');
  promptInput.type = 'text';
  promptInput.placeholder = 'Optional prompt...';
  promptInput.style.flex = '1';
  promptInput.id = 'gen-prompt';
  promptInput.autocomplete = 'off';
  genBtn = document.createElement('button');
  genBtn.textContent = 'Generate Config';
  genBtn.disabled = false; // enabled while visible; selection controls gating visibility
  genStatus = document.createElement('span');
  genStatus.className = 'status muted';
  genStatus.style.marginLeft = '4px';
  controls.appendChild(promptInput);
  controls.appendChild(genBtn);
  controls.appendChild(genStatus);
  controlsWrap.appendChild(controls);
  out.appendChild(controlsWrap);
      genBtn.addEventListener('click', async () => {
        const project = projectInput.value.trim();
        if (!project) { alert('Enter project'); return; }
        if (!selected.size) { alert('Select at least one session'); return; }
        genStatus.textContent = 'Generating...';
        genBtn.disabled = true;
        try {
          const res = await fetch('/api/gen', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ project, sessions: Array.from(selected), prompt: promptInput.value.trim() || undefined })
          });
          if (!res.ok) {
            genStatus.textContent = 'Generation failed';
          } else {
            const data = await res.json();
            if (data.ok) {
              genStatus.textContent = `Generated config version ${data.version}`;
              await loadConfig();
            } else {
              genStatus.textContent = 'Generation error';
            }
          }
        } catch (e) {
          genStatus.textContent = 'Error calling /api/gen';
        } finally {
          genBtn.disabled = selected.size === 0;
        }
      });
      function updateGenControls(sel) {
        // Show wrap only if at least one session selected
        if (sel.size > 0) {
          controlsWrap.style.display = 'block';
          genStatus.textContent = '';
        } else {
          controlsWrap.style.display = 'none';
          genStatus.textContent = '';
        }
      }
    }

    // Removed separate session selection block in favor of inline checkboxes
    // (Removed stale duplicate genBtn handler that referenced deprecated selectedSessions())

    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }
  </script>
</body>
</html>